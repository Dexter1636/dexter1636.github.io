<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Database on Dexter&#39;s Blog</title>
    <link>https://dexter1636.github.io/tags/database/</link>
    <description>Recent content in Database on Dexter&#39;s Blog</description>
    <image>
      <title>Dexter&#39;s Blog</title>
      <url>https://dexter1636.github.io/images/papermod-cover.png</url>
      <link>https://dexter1636.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.148.2</generator>
    <language>en</language>
    <copyright>2025 Dexter · CC BY-NC 4.0</copyright>
    <lastBuildDate>Sat, 05 Feb 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://dexter1636.github.io/tags/database/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数据库事务</title>
      <link>https://dexter1636.github.io/posts/others/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://dexter1636.github.io/posts/others/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</guid>
      <description>&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基本概念
&lt;ul&gt;
&lt;li&gt;ACID&lt;/li&gt;
&lt;li&gt;单对象与多对象操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;弱隔离级别
&lt;ul&gt;
&lt;li&gt;已提交读（Read Committed）&lt;/li&gt;
&lt;li&gt;快照隔离和可重复读（Snapshot Isolation and Repeatable Read）&lt;/li&gt;
&lt;li&gt;防止丢失更新（Preventing Lost Updates）&lt;/li&gt;
&lt;li&gt;写偏差和幻读（Write Skew and Phantoms）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可序列化（Serializability）
&lt;ul&gt;
&lt;li&gt;真的串行执行（Actual Serial Execution）&lt;/li&gt;
&lt;li&gt;两阶段锁（2PL, Two-Phase Locking）&lt;/li&gt;
&lt;li&gt;可序列化快照隔离（SSI, Serializable Snapshot Isolation）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;小结&lt;/li&gt;
&lt;li&gt;附录：常见事务并发问题的基本概念整理&lt;/li&gt;
&lt;li&gt;Reference&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;数据库系统可能出现各种错误，包括软硬件故障，网络故障，并发故障等等。我们需要保证发生这些故障时数据的正确性。&lt;/p&gt;
&lt;p&gt;数十年来，事务一直是简化这些问题的首选机制。 &lt;strong&gt;事务是将多个读写操作组合成一个逻辑单元的一种方式，整个事务被视作单个操作来进行，要么全部成功（commit），要么全部失败（abort，rollback）。&lt;/strong&gt; 这样一来，事务就给予了我们一定程度上的安全保证，使得我们不用担心部分失败的情况，以及部分并发问题。&lt;/p&gt;
&lt;h3 id=&#34;acid&#34;&gt;ACID&lt;/h3&gt;
&lt;h4 id=&#34;原子性atomicity&#34;&gt;原子性（Atomicity）&lt;/h4&gt;
&lt;p&gt;事务的所有操作要么全部成功，要么全部失败。&lt;/p&gt;
&lt;h4 id=&#34;一致性consistency&#34;&gt;一致性（Consistency）&lt;/h4&gt;
&lt;p&gt;对数据的一组特定陈述必须始终成立。&lt;/p&gt;
&lt;p&gt;例如，在会计系统中，所有账户整体上必须借贷相抵。&lt;/p&gt;
&lt;h4 id=&#34;隔离性isolation&#34;&gt;隔离性（Isolation）&lt;/h4&gt;
&lt;p&gt;同时执行的事务是相互隔离的，它们不能互相影响。&lt;/p&gt;
&lt;p&gt;隔离性用于防止并发问题。&lt;/p&gt;
&lt;h4 id=&#34;持久性durability&#34;&gt;持久性（Durability）&lt;/h4&gt;
&lt;p&gt;一旦事务提交，其所做的修改会永远保存到数据库中。&lt;/p&gt;
&lt;h4 id=&#34;综合理解&#34;&gt;综合理解&lt;/h4&gt;
&lt;p&gt;原子性和隔离性保证了一致性。&lt;/p&gt;
&lt;p&gt;持久性保证数据不会丢失。&lt;/p&gt;
&lt;h3 id=&#34;单对象与多对象操作&#34;&gt;单对象与多对象操作&lt;/h3&gt;
&lt;h4 id=&#34;概念&#34;&gt;概念&lt;/h4&gt;
&lt;p&gt;单对象操作是指在一个事务中只对单个对象进行了操作，多对象操作是指在一个事务中对数据库中的多个对象进行了操作。&lt;/p&gt;
&lt;h4 id=&#34;单对象写入&#34;&gt;单对象写入&lt;/h4&gt;
&lt;p&gt;可能发生的错误：丢失更新（lost update）。&lt;/p&gt;
&lt;img src=&#34;assets/ddia_0701.png&#34; style=&#34;zoom:25%;&#34; /&gt;
&lt;p&gt;因此需要保证原子性和隔离性。其中原子性可以通过undo日志来保证，隔离性可以通过给对象上锁来保证。&lt;/p&gt;
&lt;p&gt;一些数据库也提供更复杂的原子操作，比如自增操作，这样就不需要“读取-修改-写入”的操作序列了。另一种解决办法是使用CAS操作。&lt;/p&gt;
&lt;h4 id=&#34;多对象事务&#34;&gt;多对象事务&lt;/h4&gt;
&lt;p&gt;有些情况下一个事务需要对多个对象进行读写操作。&lt;/p&gt;
&lt;p&gt;例如一个邮件系统，&lt;code&gt;emails&lt;/code&gt;表存储邮件，&lt;code&gt;mailboxs&lt;/code&gt;表存储用户的未读邮件数量。当用户收到新邮件时，可能会产生下面的错误（脏读）。&lt;/p&gt;
&lt;img src=&#34;assets/ddia_0702.png&#34; style=&#34;zoom: 25%;&#34; /&gt;
&lt;h4 id=&#34;错误处理与中止&#34;&gt;错误处理与中止&lt;/h4&gt;
&lt;p&gt;错误处理与中止（abort）保证了事务的原子性。如果发生错误，事务可以中止并被安全地重试。&lt;/p&gt;
&lt;p&gt;然而，错误处理与中止机制也存在它的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果事务实际上成功了，但是在服务器试图向客户端确认提交成功时网络发生故障（所以客户端认为提交失败了），那么重试事务会导致事务被执行两次，除非你有一个额外的应用级除重机制。&lt;/li&gt;
&lt;li&gt;如果错误是由于负载过大造成的，则重试事务将使问题变得更糟，而不是更好。为了避免这种负反馈循环，可以限制重试次数，使用指数退避算法，并单独处理与过载相关的错误（如果允许）。&lt;/li&gt;
&lt;li&gt;仅在临时性错误（例如，由于死锁，异常情况，临时性网络中断和故障切换）后才值得重试。在发生永久性错误（例如，违反约束）之后重试是毫无意义的。&lt;/li&gt;
&lt;li&gt;如果事务在数据库之外也有副作用，即使事务被中止，也可能发生这些副作用。例如，副作用是发送电子邮件，那你肯定不希望每次重试事务时都重新发送电子邮件。如果你想确保几个不同的系统一起提交或放弃，可以使用两阶段提交（2PC, two-phase commit）。&lt;/li&gt;
&lt;li&gt;如果客户端进程在重试中失效，任何试图写入数据库的数据都将丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;弱隔离级别&#34;&gt;弱隔离级别&lt;/h2&gt;
&lt;p&gt;数据库提供事务隔离（transaction isolation）来隐藏应用程序开发者的并发问题。但是，隔离级别越高，系统性能就越低，所以我们通常使用较弱的隔离级别来防止一部分，而不是全部的并发问题。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
